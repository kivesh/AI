import javax.swing.JOptionPane;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Stack;

import javax.swing.JOptionPane;

/**
 *
 * @author Student
 */
public class MainF extends javax.swing.JFrame {

	Node myTree = null;
	String strPeople;
	int totalTime;
	private static ArrayList<Node> open = new ArrayList<Node>();
	private static ArrayList<Node> closed = new ArrayList<Node>();

	private static LinkedList<Node> openL = new LinkedList<Node>();
	private static LinkedList<Node> closedL = new LinkedList<Node>();

	private static ArrayList<Node> visited = new ArrayList<Node>();
	private static ArrayList<Node> path = new ArrayList<Node>();

	/**
	 * Creates new form MainF
	 */
	public MainF() {
		initComponents();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed" desc="Generated
	// Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		jPanel1 = new javax.swing.JPanel();
		jLabel1 = new javax.swing.JLabel();
		jLabel2 = new javax.swing.JLabel();
		ButtonBegin = new javax.swing.JButton();
		jScrollPane1 = new javax.swing.JScrollPane();
		jTextArea1 = new javax.swing.JTextArea();
		ButtonClear = new javax.swing.JButton();
		DSearch = new javax.swing.JButton();
		BSearch = new javax.swing.JButton();
		ASearch = new javax.swing.JButton();

		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
		setBackground(new java.awt.Color(51, 204, 255));

		jPanel1.setBackground(new java.awt.Color(51, 255, 153));

		jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
		jLabel1.setText("COMP304 Assignment 1");

		jLabel2.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
		jLabel2.setForeground(new java.awt.Color(0, 0, 255));
		jLabel2.setText("217001412");

		ButtonBegin.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
		ButtonBegin.setForeground(new java.awt.Color(204, 0, 0));
		ButtonBegin.setText("Enter Numbers");
		ButtonBegin.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				ButtonBeginActionPerformed(evt);
			}
		});

		jTextArea1.setColumns(20);
		jTextArea1.setRows(5);
		jScrollPane1.setViewportView(jTextArea1);

		ButtonClear.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
		ButtonClear.setText("Clear");
		ButtonClear.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				ButtonClearActionPerformed(evt);
			}
		});

		DSearch.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
		DSearch.setForeground(new java.awt.Color(255, 0, 0));
		DSearch.setText("Depth First Search");
		DSearch.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				DSearchActionPerformed(evt);
			}
		});

		BSearch.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
		BSearch.setForeground(new java.awt.Color(0, 102, 0));
		BSearch.setText("Breadth First Search");
		BSearch.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				BSearchActionPerformed(evt);
			}
		});

		ASearch.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
		ASearch.setForeground(new java.awt.Color(153, 0, 153));
		ASearch.setText("A* Search");
		ASearch.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				ASearchActionPerformed(evt);
			}
		});

		javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
		jPanel1.setLayout(jPanel1Layout);
		jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(jPanel1Layout.createSequentialGroup().addGroup(jPanel1Layout
						.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(jPanel1Layout.createSequentialGroup().addContainerGap(306, Short.MAX_VALUE)
								.addComponent(jLabel1).addGap(79, 79, 79).addComponent(jLabel2).addGap(268, 268, 268))
						.addGroup(jPanel1Layout.createSequentialGroup().addContainerGap()
								.addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
										.addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
										.addComponent(ButtonClear, javax.swing.GroupLayout.DEFAULT_SIZE,
												javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
										.addComponent(ButtonBegin, javax.swing.GroupLayout.DEFAULT_SIZE,
												javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
										.addGroup(jPanel1Layout.createSequentialGroup()
												.addComponent(BSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 300,
														javax.swing.GroupLayout.PREFERRED_SIZE)
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED,
														javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
												.addComponent(DSearch, javax.swing.GroupLayout.PREFERRED_SIZE, 300,
														javax.swing.GroupLayout.PREFERRED_SIZE)
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
												.addComponent(ASearch, javax.swing.GroupLayout.PREFERRED_SIZE, 300,
														javax.swing.GroupLayout.PREFERRED_SIZE)))))
						.addContainerGap()));
		jPanel1Layout
				.setVerticalGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(jPanel1Layout.createSequentialGroup().addContainerGap(14, Short.MAX_VALUE)
								.addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
										.addComponent(jLabel2).addComponent(jLabel1))
								.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
								.addComponent(ButtonBegin)
								.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
								.addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
										.addComponent(DSearch).addComponent(BSearch).addComponent(ASearch))
								.addGap(4, 4, 4)
								.addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 400,
										javax.swing.GroupLayout.PREFERRED_SIZE)
								.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
								.addComponent(ButtonClear).addGap(8, 8, 8)));

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(
				jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE));
		layout.setVerticalGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addComponent(
				jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE));

		pack();
	}// </editor-fold>//GEN-END:initComponents

	private void ButtonClearActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_ButtonClearActionPerformed
		// TODO add your handling code here:
		jTextArea1.setText("");
	}// GEN-LAST:event_ButtonClearActionPerformed

	private void ButtonBeginActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_ButtonBeginActionPerformed
		// TODO add your handling code here:

		try {
			int n = Integer.parseInt(JOptionPane.showInputDialog("Enter the size of n in the range [3-5]."));
			if (n > 2 && n < 6) {
				int[] time = new int[n];

				strPeople = "(";
				for (int k = 0; k < n; k++) {

					time[k] = Integer.parseInt(
							JOptionPane.showInputDialog("Enter persons " + (k + 1) + " time needed to cross: "));
					;
					strPeople += time[k] + ",";

				}

				strPeople = strPeople.substring(0, strPeople.length() - 1) + ")";
				totalTime = Integer.parseInt(JOptionPane.showInputDialog("Enter total time needed to cross: "));

				strPeople += " And " + totalTime;
				myTree = new Node(time);
				jTextArea1.setText(strPeople);
			} else {
				jTextArea1.setText("N not within range [3-5].");
			}

		} catch (Exception e) {
			jTextArea1.setText("Numerical Error-Enter numerical values only.");
		}

	}// GEN-LAST:event_ButtonBeginActionPerformed

	private void BSearchActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_BSearchActionPerformed
		// TODO add your handling code here:

		if (myTree == null) {
			jTextArea1.setText("Enter values for the people first!");
		} else {
			jTextArea1.setText(strPeople + "\n" + bfs(myTree, totalTime));
		}
	}// GEN-LAST:event_BSearchActionPerformed

	private void DSearchActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_DSearchActionPerformed
		// TODO add your handling code here:
		if (myTree == null) {
			jTextArea1.setText("Enter values for the people first!");

		} else {
			jTextArea1.setText(strPeople + "\n" + dfs(myTree, totalTime));
		}
	}// GEN-LAST:event_DSearchActionPerformed

	private void ASearchActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_ASearchActionPerformed
		// TODO add your handling code here:
		if (myTree == null) {
			jTextArea1.setText("Enter values for the people first!");
		} else {
			jTextArea1.setText(strPeople + "\n" + ASearch(myTree));
		}
	}// GEN-LAST:event_ASearchActionPerformed

	/**
	 * @param args the command line arguments
	 */
	public static void main(String args[]) {
		/* Set the Nimbus look and feel */
		// <editor-fold defaultstate="collapsed" desc=" Look and feel setting code
		// (optional) ">
		/*
		 * If Nimbus (introduced in Java SE 6) is not available, stay with the default
		 * look and feel. For details see
		 * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
		 */
		try {
			for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
				if ("Nimbus".equals(info.getName())) {
					javax.swing.UIManager.setLookAndFeel(info.getClassName());
					break;
				}
			}
		} catch (ClassNotFoundException ex) {
			java.util.logging.Logger.getLogger(MainF.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		} catch (InstantiationException ex) {
			java.util.logging.Logger.getLogger(MainF.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		} catch (IllegalAccessException ex) {
			java.util.logging.Logger.getLogger(MainF.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		} catch (javax.swing.UnsupportedLookAndFeelException ex) {
			java.util.logging.Logger.getLogger(MainF.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
		}
		// </editor-fold>

		/* Create and display the form */
		java.awt.EventQueue.invokeLater(new Runnable() {
			public void run() {
				new MainF().setVisible(true);
			}
		});
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JButton ASearch;
	private javax.swing.JButton BSearch;
	private javax.swing.JButton ButtonBegin;
	private javax.swing.JButton ButtonClear;
	private javax.swing.JButton DSearch;
	private javax.swing.JLabel jLabel1;
	private javax.swing.JLabel jLabel2;
	private javax.swing.JPanel jPanel1;
	private javax.swing.JScrollPane jScrollPane1;
	private javax.swing.JTextArea jTextArea1;
	// End of variables declaration//GEN-END:variables

	public static String ASearch(Node myTree) {
		path = new ArrayList<Node>();
		open = new ArrayList<Node>();
		visited = new ArrayList<Node>();
		Node currentNode = myTree;
		ArrayList<Node> Nodeschildren = null;
		open.add(currentNode);
		path.add(currentNode);
		visited.add(currentNode);
		while (!open.isEmpty()) {
			currentNode = open.get(0);
			open.remove(0);

			if (currentNode.isLeaf == true) {

			} else {

				Nodeschildren = currentNode.getChildren();

				Node minNode = Nodeschildren.get(0);
				visited.add(minNode);
				Node compareNode;
				int minFofN;
				int compareFofN;
				for (int i = 1; i < Nodeschildren.size(); i++) {
					compareNode = Nodeschildren.get(i);
					visited.add(compareNode);
					minFofN = minNode.heuristic + minNode.value; // heuristic + cost
					compareFofN = compareNode.heuristic + compareNode.value;

					if (compareFofN < minFofN) {
						minNode = compareNode;
					}

				}

				path.add(minNode);
				open.add(minNode);
			}

		}

		String printString = "A* Search\n";
		//String leftRightString = "\n\n\n";
		for (int p = 0; p < path.size(); p++) {
			printString += "\n" + path.get(p).action ;
			//leftRightString+= "-->Left ["+closed.get(p).left+"] "+" Rigth ["+closed.get(p).right+"]    ";
			// System.out.println( path.get(p).action );
		}
		 printString += "\n\nThe number of nodes traversed: "+path.size();
		return printString + "\n";
		// System.out.println("Nodes visited: " + visited.size());
		// for(int j=0; j< visited.size(); j++)
		// {
		// System.out.println(visited.get(j).action);
		// }

	}

	public static String bfs(Node myTree, int Value) {
		open = new ArrayList<Node>();
		closed = new ArrayList<Node>();
		Node currentNode = myTree;
		ArrayList<Node> Nodeschildren = null;
		open.add(currentNode);

		while (!open.isEmpty()) {
			currentNode = open.get(0);
			open.remove(0);

			Nodeschildren = currentNode.getChildren();

			if (Nodeschildren.size() > 0) {
				for (int i = 0; i < Nodeschildren.size(); i++) {
					open.add(Nodeschildren.get(i));
				}
			}
			closed.add(currentNode);
			if (currentNode.left.equals("") && (currentNode.getValue() <= Value)) {
				break;
			}

		}

		String printString = "Breadth First Search\n";
	

		for (int p = 0; p < closed.size(); p++) {
			printString += "\n" + closed.get(p).action;
			
			// System.out.println( path.get(p).action );
		}
       printString += "\n\nThe number of nodes traversed: "+closed.size();
		return printString+"\n" ;
	
	}

	public static String dfs(Node myTree, int Value) {
		openL = new LinkedList<Node>();
		closed = new ArrayList<Node>();
		Node currentNode = myTree;
		ArrayList<Node> Nodeschildren = null;
		openL.addFirst(currentNode);

		while (!openL.isEmpty()) {
			currentNode = openL.removeFirst();

			Nodeschildren = currentNode.getChildren();
			if (Nodeschildren.size() > 0) {
				for (int i = Nodeschildren.size() - 1; i >= 0; i--) {
					openL.addFirst(Nodeschildren.get(i));

				}

			}

			closed.add(currentNode);
			if (currentNode.left.equals("") && (currentNode.getValue() <= Value)) {
				break;
			}

		}

		String printString = "Depth First Search\n";
	
		for (int p = 0; p < closed.size(); p++) {
			printString += "\n" + closed.get(p).action;
			
		}
       printString += "\n\nThe number of nodes traversed: "+closed.size();
		return printString+"\n" ;

	}

	static class Node {

		public ArrayList<Node> children;

		public int size = 0;

		public int value; // Cost
		public String action;// Action in english
		public String left; // People on the left
		public String right; // People on the right
		public char operation;
		public boolean isLeaf = false;
		public int heuristic;

		public Node(int v) {
			this.value = v;
			children = new ArrayList<Node>();
		}

		public Node(int v, String a) {
			v = value;
			a = action;
		}

		public Node(char op, int v, String a, String Left, String Right, boolean leaf, int h) {
			operation = op;
			value = v;
			action = a;
			left = Left;
			right = Right;
			isLeaf = leaf;
			heuristic = h;
			children = new ArrayList<Node>();
		}

		public Node(int[] peopleValue) {
			this.value = 0;
			heuristic = peopleValue.length;
			children = new ArrayList<Node>();
			right = "";
			left = "";
			operation = '+';
			if (true) {
				for (int i = 0; i < peopleValue.length; i++) {
					left += peopleValue[i] + " ";
				}
				left = left.substring(0, left.length() - 1);
				value = 0;

				right = "";
				action = left + " Havent crossed yet";
				generateTree(this);
			}

		}

		public int getValue() {
			return value;
		}

		public String getAction() {
			return action;
		}

		public void setAction(String action) {
			this.action = action;
		}

		public ArrayList<Node> getChildren() {
			return children;
		}

		public void addChildren(int val) {
			children.add(new Node(val));
			size++;
		}

		public Node addReturnChild(char op, int v, String a, String Left, String Right, boolean leaf, int h) {
			Node child = new Node(op, v, a, Left, Right, leaf, h);

			children.add(child);
			size++;
			return child;
		}

		public Node getCorrectChild(int value) // will only add children to the second level
		{
			if (size > 0) {
				for (int j = 0; j < size; j++) {
					if (children.get(j).getValue() == value) {
						return children.get(j);
					}
				}

				return null;
			} else {
				return null;
			}
		}

		public void generateTree(Node parent) {
			Stack<Node> myStack = new Stack<Node>();
			myStack.push(parent);
			Node currentParent;
			while (!myStack.isEmpty()) {
				currentParent = myStack.pop();
				if (currentParent.isLeaf == false) {
					if (currentParent.operation == '+') {

						int[] leftValues;
						if (currentParent.left.length() > 1) {
							String[] leftPeep = currentParent.left.split(" ");

							leftValues = new int[leftPeep.length];

							for (int k = 0; k < leftPeep.length; k++) {
								leftValues[k] = Integer.parseInt(leftPeep[k]);
							}

							if (leftValues.length == 2)// Take those two people accross
							{

								int newValue;
								if (leftValues[0] > leftValues[1]) {
									newValue = currentParent.value + leftValues[0];
								} else if (leftValues[1] > leftValues[0]) {
									newValue = currentParent.value + leftValues[1];
								} else {
									newValue = currentParent.value + leftValues[0];
								}

								String a = leftValues[0] + " And " + leftValues[1] + " walks across with total time "
										+ newValue + " minutes.";
								String newRight = currentParent.right + " " + leftValues[0] + " " + leftValues[1];

								myStack.push(currentParent.addReturnChild('-', newValue, a, "", newRight, true, 0));

							} else // Take all possible combinations across
							{
								int h;

								String remainingLeftPeople = "";

								for (int q = 0; q < leftValues.length; q++) {

									for (int w = 0; w < leftValues.length; w++) {

										if (w > q) // Take these two accross
										{
                                            h=Integer.MAX_VALUE;
											for (int e = 0; e < leftValues.length; e++) {
												if ((leftValues[e] != leftValues[w])
														&& (leftValues[e] != leftValues[q])) {
													remainingLeftPeople += leftValues[e] + " ";
												}
												else
												{
													if(leftValues[e]<h)
													{
														h = leftValues[e];
													}
												}
												
											}
											remainingLeftPeople = remainingLeftPeople.substring(0,
													remainingLeftPeople.length() - 1);

											int newValue;
											if (leftValues[q] > leftValues[w]) {
												newValue = currentParent.value + leftValues[q];
												
											} else if (leftValues[w] > leftValues[q]) {
												newValue = currentParent.value + leftValues[w];
												
											} else {
												newValue = currentParent.value + leftValues[q];
											   
											}

											String a = leftValues[q] + " And " + leftValues[w]
													+ " walks across with total time " + newValue + " minutes.";
											String newRight;
											if (currentParent.right.equals("")) {
												newRight = leftValues[q] + " " + leftValues[w];
											} else {
												newRight = currentParent.right + " " + leftValues[q] + " "
														+ leftValues[w];
											}

											
										
											myStack.push(currentParent.addReturnChild('-', newValue, a,
													remainingLeftPeople, newRight, false, h));

											remainingLeftPeople = "";
										}
									}

								}

							}

						} else// Take that person accross
						{

							int newValue = currentParent.value + (int) (currentParent.left.charAt(0)) - 48;
							String a = currentParent.left.charAt(0) + " walks across with total time " + newValue
									+ " minutes.";
							String newRight = currentParent.right + " " + currentParent.left.charAt(0);
							myStack.push(currentParent.addReturnChild('-', newValue, a, "", newRight, true, 0));
						}

					} else // Bring a person back with the torch operation -
					{

						if (true) {
							String[] rightPeep = currentParent.right.split(" ");

							int[] rightValues = new int[rightPeep.length];

							for (int k = 0; k < rightPeep.length; k++) {
								rightValues[k] = Integer.parseInt(rightPeep[k]);
							}

							// Take one of the right people accross
							int newValue;
							String a, newLeft;
							String remainingRight = "";
							for (int j = 0; j < rightValues.length; j++) {
								for (int e = 0; e < rightValues.length; e++) {
									if (e != j) {
										remainingRight += rightValues[e] + " ";
									}
								}
								remainingRight = remainingRight.substring(0, remainingRight.length() - 1);

								newValue = currentParent.value + rightValues[j];
								a = rightValues[j] + " walks back carrying the Torch with total time " + newValue
										+ " minutes.";
								newLeft = currentParent.left + " " + rightValues[j];

								String[] leftPeep = newLeft.split(" ");
								
								int h = Integer.MAX_VALUE;
								for(int k=0; k<leftPeep.length; k++)
								{
									if(Integer.parseInt(leftPeep[k])<h)
									{
										h = Integer.parseInt(leftPeep[k]);
									}
								}
								
								
							
								
								myStack.push(currentParent.addReturnChild('+', newValue, a, newLeft, remainingRight,
										false, h));

								remainingRight = "";
							}
						}

					}
				}

				else {
					// Its a leaf
				}
			}
		}

	}

}
